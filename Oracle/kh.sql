select * from employee;
select * from employee WHERE emp_name='선동일';

--EMPLOYEE테이블에서 JOB_CODE가 J5인 직원의 이름, 전화번호 출력
select EMP_NAME, PHONE from employee WHERE job_code='J5';

--job 테이블에서 job_name의 정보만 출력
select job_name from job;

-- department테이블의 모든 정보 출력
SELECT * FROM department;

--employee 테이블에서 이름emp_name 이메일email 전화번호phone 월급salary 출력
select emp_name,email,phone,salary from employee;

--EMPLOY테이블에서 월급이 250이상 이면서 직급코드(JOB_CODE)가 J3인사람
select emp_name,email,phone,salary from employee WHERE SALARY>=2500000 AND JOB_CODE='J3';

SELECT EMP_NAME,SALARY,SALARY*12 FROM EMPLOYEE;

SELECT EMP_NAME AS "이름",SALARY "월급",SALARY*12 연봉,(SALARY+(SALARY*BONUS))*12 "연봉(보너스포함)" FROM EMPLOYEE;

SELECT EMP_NAME, SALARY||'원' 월급,SALARY/10000 만원 FROM EMPLOYEE;

--급여가 350만원 이상, 600만원 이하인 직원의 이름 , 급여 출력
SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY BETWEEN 3500000 AND 6000000;

--LIKE, NOT LIKE
--와일드카드 %,_
-- % : 글자수 제한 없이 대체
-- _ :한 글자를 대체

SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE EMP_NAME LIKE '전__';
SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE EMP_NAME LIKE '전%';
SELECT EMP_NAME, EMAIL FROM EMPLOYEE WHERE EMAIL LIKE '___#_%'ESCAPE'#';

-- 1. EMPLOYEE 테이블에서 이름 끝이 연으로 끝나는 사원의 이름, 급여 출력
-- 2. 전화번호 첫 3자리가 010이 아닌 직원의 이름 전화번호 출력
-- 3. 이메일주소에 s가 들어가면서 DEPT_CODE가 D9 또는 D6인 직원의 이름, 이메일, 부서코드 출력
SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE EMP_NAME LIKE '%연';
SELECT EMP_NAME, PHONE FROM EMPLOYEE WHERE PHONE NOT LIKE '010%';
SELECT EMP_NAME, EMAIL,DEPT_CODE FROM EMPLOYEE WHERE EMAIL LIKE '%s%' AND (DEPT_CODE ='D9' OR DEPT_CODE ='D6');

SELECT EMP_NAME, SALARY, BONUS FROM EMPLOYEE WHERE BONUS IS NOT NULL;

SELECT EMP_NAME, DEPT_CODE FROM EMPLOYEE WHERE DEPT_CODE IN ('D9','D6','D8');

--------------------------------------------------------------
--문자열 길이 반환 (LENGTH)
SELECT EMP_NAME,LENGTH(EMP_NAME) FROM EMPLOYEE;

--문자열 BYTE 반환 (LENTHB)
SELECT EMP_NAME,LENGTHB(EMP_NAME) FROM EMPLOYEE;


--찾는 문자열이 지정한 위치부터 지정한 횟수에 나타난 위치 반환 (INSTR)
--OO문자열에서 O를 O번째부터 찾는데 O번째꺼를 찾아라
SELECT 'Hello World Hi Hign' FROM DUAL;
SELECT INSTR('Hello World Hi Hign','H',1,1) FROM DUAL;
SELECT INSTR('Hello World Hi Hign','H',1,2) FROM DUAL;
--음수일 경우 뒤에서부터 서치함.
SELECT INSTR('Hello World Hi Hign','H',-1,1) FROM DUAL;

SELECT EMP_NAME, EMAIL,INSTR(EMAIL,'@',1,1) FROM EMPLOYEE;

-- LPAD/RPAD : 주어진 컬럼 문자열에 임의의 문자열을 왼쪽/오른쪽에 덧붙임
-- LPAD는 왼쪽에 RPAD는 오른쪽에 채워넣음.
SELECT EMAIL,LENGTH(EMAIL),LPAD(EMAIL,20,'#') FROM EMPLOYEE;

-- LTRIM/RTRIM : 주어진 컬럼이나 문자열의 왼쪽 또는 오른쪽에서 
-- 지정한 문자열에 포함된 모든 문자를 제거한 나머지 반환
SELECT LTRIM('000KH000','0') FROM DUAL;
--이거도 다 지워짐
SELECT LTRIM('123231233123123123KH000','123') FROM DUAL;

--TRIM : 주어진 컬럼이나 문자열의 앞/뒤/양쪽에 있는
-- 지정한 문자를 제거한 나머지 반환하지만 한문자만 가능.
SELECT '000KH000' FROM DUAL;
SELECT TRIM('0' FROM '000KH000') FROM DUAL;
--양쪽에서 삭제
SELECT TRIM(BOTH '0' FROM '000KH000') FROM DUAL;
--앞부분만 삭제
SELECT TRIM(LEADING '0' FROM '000KH000') FROM DUAL;
--뒷부분만 삭제
SELECT TRIM(TRAILING '0' FROM '000KH000') FROM DUAL;

--SUBSTR : 컬럼이나 문자열에서 지정한 위치부터 지정한 개수의
--문자열을 잘라내어 리턴
SELECT 'SHOW ME THE MONEY' FROM DUAL;
--6번째 포함 2칸만.
SELECT SUBSTR('SHOW ME THE MONEY',6,2) FROM DUAL;
--9번째부터 끝까지 다
SELECT SUBSTR('SHOW ME THE MONEY',9) FROM DUAL;

--1. EMPLOYEE 테이블에서 사원이름 중 성만 출력
--2. EMPLOYEE 테이블에서 남자사원만 사원번호,이름 주민번호,월급 출력
--단, 주민번호 출력 시 뒤 6자리는 *로 출력
SELECT SUBSTR(EMP_NAME,'1','1') FROM EMPLOYEE;
SELECT DEPT_CODE,EMP_NAME,RPAD(SUBSTR(EMP_NO,1,8),14,'*'),SALARY FROM EMPLOYEE WHERE SUBSTR(EMP_NO,8,1)=1;
----------------------------------------------------------------
--7/15
--LOWER / UPPER  / INITCAP
SELECT LOWER('Welcome To Oracle') FROM DUAL;
SELECT UPPER('Welcome To Oracle') FROM DUAL;
SELECT INITCAP('Welcome To Oracle') FROM DUAL;

--CONCAT : 문자열 두개를 받아 하나로 합쳐서 리턴
SELECT CONCAT('가나다라','ABCD') FROM DUAL;
SELECT CONCAT(CONCAT('가나다라','ABCD'),'1111') FROM DUAL; -- 이미 연결된 출력문에 중복 연결시 중복된 수 만큼 연산자로 묶어줘야함

-- = SELECT '가나다라'||'ABCD' FROM DUAL;

-- REPLACE(STR1,STR2,STR3) : 문자열 3개를 매개변수로 받아서
-- STR1 문자열 중 STR2의 내용을 STR3으로 수정
SELECT REPLACE(EMAIL,'kh','iei')FROM EMPLOYEE;

--ABS : 절대값
SELECT ABS(10),ABS(-10) FROM DAUL;
--MOD : 나머지 연산
SELECT MOD(10,3) FROM DUAL;
--ROUND : 반올림
SELECT ROUND(123.556) FROM DUAL;
SELECT ROUND(123.456,1) FROM DUAL;
SELECT ROUND(123.456,2) FROM DUAL;
SELECT ROUND(123.456,-1) FROM DUAL;

--FLOOR : 버림(자리수 지정 불가, 소수점 무조건 다 버림)
SELECT FLOOR(123.567) FROM DUAL;
--TRUNC : 소수점 자리수 버림
SELECT TRUNC(123.567,1) FROM DUAL;
SELECT TRUNC(123.567,-1) FROM DUAL;
--CEIL : 올림
SELECT CEIL(123.456) FROM DUAL;
-------------------------------------------------
--현재 시간 함수
SELECT SYSDATE,CURRENT_DATE, LOCALTIMESTAMP,CURRENT_TIMESTAMP FROM DUAL;

--MONTHS_BETWEEN(DATE1, DATE2) : 두 날짜의 개월 수 차이를 반환
SELECT EMP_NAME,HIRE_DATE,FLOOR(MONTHS_BETWEEN(SYSDATE,HIRE_DATE)) FROM EMPLOYEE;

--ADD_MONTHS(DATE,NUMBER) : 매개변수로 받은 날짜에 매개변수로 받은 숫자만큼 개월수를 더해서 리턴

--NEXT_DAT(DATE, STRING[NUMBER]): 매개변수로 받은 날짜
SELECT SYSDATE, NEXT_DAY(SYSDATE, '목요일') FROM DUAL;
SELECT SYSDATE, NEXT_DAY(SYSDATE, '수') FROM DUAL;
-- 1=일요일 ~ 7=토요일
SELECT SYSDATE, NEXT_DAY(SYSDATE,2) FROM DUAL;

--LAST_DAY(DATE) : 매개 변수로 받은 날짜가 속한 달의 마지막 날짜를 구해서 리턴
SELECT SYSDATE, LAST_DAY(SYSDATE) FROM DUAL;
SELECT ADD_MONTHS(SYSDATE,2), LAST_DAY(ADD_MONTHS(SYSDATE,2)) FROM DUAL;

--EXTRACT : 원하는 부분만 추출 후 출력
SELECT 
    SYSDATE,
    EXTRACT(YEAR FROM SYSDATE),
    EXTRACT(MONTH FROM SYSDATE),
    EXTRACT(DAY FROM SYSDATE)
FROM DUAL;

SELECT EMP_NAME,
    EXTRACT(YEAR FROM HIRE_DATE)||'년'||
    EXTRACT(MONTH FROM HIRE_DATE)||'월'||
    EXTRACT(DAY FROM HIRE_DATE)||'일' 입사일
FROM EMPLOYEE;

-------------------------------------------
SELECT TO_CHAR(SYSDATE,'YYYY-MM-DD') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY/MM/DD/DAY') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY/MONTH/DD') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY-MM-DD HH:MI:SS') FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY"년"MM"월"DD"일" HH"시"MI"분"SS"초"') FROM DUAL;
--FM : 07월 -> 7월 만듬
SELECT TO_CHAR(SYSDATE,'FMYYYY"년"MM"월"DD"일" HH"시"MI"분"SS"초"') FROM DUAL;

SELECT EMP_NAME, HIRE_DATE, TO_CHAR(HIRE_DATE,'YYYY-MM-DD') 입사일 FROM EMPLOYEE;

--숫자에서 문자로 변환
--0 OR 9를 통해서 숫자의 최대 갯수를 표현
--100 -> 00000,99999
--변환될 숫자 길이보다 포맷 길이가 길어야함.
SELECT 10000, TO_CHAR(10000,'000,000,000') FROM DUAL;
SELECT 10000, TO_CHAR(10000,'999,999,999') FROM DUAL;
SELECT 10000, TO_CHAR(10000,'999,999,999.9999') FROM DUAL;
--우리나라 통화 단위는 L이 붙음
SELECT 10000, TO_CHAR(10000,'L999,999,999') FROM DUAL;
SELECT EMP_NAME, TO_CHAR(SALARY,'L999,999,999') 월급 FROM EMPLOYEE;

--TO_DATE 
SELECT TO_DATE(20220715,'YYYYMMDD') FROM EMPLOYEE;
SELECT TO_CHAR(TO_DATE(20220715,'YYYYMMDD'),'YYYY-MM-DD HH24:MI:SS') FROM EMPLOYEE;

--EMPLOYEE 테이블에서 2000년도 이후(포함)에 입사한 사원의 이름, 입사일
SELECT EMP_NAME,HIRE_DATE FROM EMPLOYEE WHERE EXTRACT(YEAR FROM HIRE_DATE) >= 2000;
SELECT EMP_NAME,HIRE_DATE FROM EMPLOYEE WHERE HIRE_DATE >= TO_DATE(20000101,'YYYYMMDD');
SELECT TO_NUMBER('10,000', '99,999') FROM DUAL;

-------------------------------------------------------
--NVL : NULL처리 함수
SELECT EMP_NAME,SALARY,NVL(BONUS,0),SALARY*12 연봉,(SALARY+(SALARY*NVL(BONUS,0)))*12 "연봉(보너스포함)" FROM EMPLOYEE;

------------------------------------------------
--DECODE 선택 함수1: 여러가지 경우에 선택 할 수 있는 기능제공
--조건 결과 조건 결과, 홀수일 경우 가장 뒷자리는 default의 기능.
SELECT EMP_NAME,EMP_NO,DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') 성별 FROM EMPLOYEE;
--CASE : 여러가지 경우 선택할 수 있는 기능제공(범위값도 가능)
SELECT 
    EMP_NAME,
    EMP_NO,
    CASE 
        WHEN SUBSTR(EMP_NO,8,1)=1 OR SUBSTR(EMP_NO,8,1)=3
        THEN '남'  
        WHEN SUBSTR(EMP_NO,8,1) IN (2,4)
        THEN '여' 
        ELSE '?'
    END AS 성별
FROM EMPLOYEE;
-------------------------------------
--SUM : 해당 컬럼 총합
SELECT SUM(SALARY) FROM EMPLOYEE WHERE SUBSTR(EMP_NO,8,1)=1;

--AVG : 해당 컬럼 값들의 평균
SELECT AVG(SALARY) FROM EMPLOYEE;
--NULL값은 평균값에서 계산이 안돌아가버림.
SELECT AVG(NVL(BONUS,0)) FROM EMPLOYEE;
--COUNT : 조회한 LOW 갯수 반환

SELECT MAX(SALARY),MIN(SALARY) FROM EMPLOYEE;

SELECT * FROM EMPLOYEE;

SELECT EMP_NAME 직원명,EMAIL 이메일, LENGTH(EMAIL) 이메일길이 FROM EMPLOYEE;
SELECT EMP_NAME,SUBSTR(EMAIL,1,INSTR(EMAIL,'@')-1) 이메일아이디 FROM EMPLOYEE;
SELECT EMP_NAME 직원명,SUBSTR(EMP_NO,1,2) 년생,NVL(BONUS,0) FROM EMPLOYEE WHERE SUBSTR(EMP_NO,1,1)=6;
SELECT COUNT(EMP_NAME)||'명' AS 인원 FROM EMPLOYEE WHERE PHONE NOT LIKE '010%';
SELECT EMP_NAME 직원명,TO_CHAR(HIRE_DATE,'FMYYYY"년"MM"월"') 입사년월 FROM EMPLOYEE;
SELECT EMP_NAME, RPAD(SUBSTR(EMP_NO,1,8),14,'*') 주민등록번호 FROM EMPLOYEE;
SELECT EMP_NAME,JOB_CODE,TO_CHAR((SALARY+(SALARY*NVL(BONUS,0)))*12,'L999,999,999') 연봉 FROM EMPLOYEE;
SELECT EMP_ID,EMP_NAME,DEPT_CODE,HIRE_DATE FROM EMPLOYEE WHERE EXTRACT(YEAR FROM HIRE_DATE) = 2004 AND (DEPT_CODE ='D5' OR DEPT_CODE='D9');
SELECT EMP_NAME 직원명,HIRE_DATE 입사일, FLOOR(SYSDATE-HIRE_DATE) 근무일수 FROM EMPLOYEE;

--SELECT  MAX(EXTRACT(YEAR FROM SYSDATE)-EXTRACT(TO_CHAR(YEAR FROM TO_DATE(EMP_NO,1,2)),'RR')) "최대나이",
--   MIN(EXTRACT(YEAR FROM SYSDATE)-EXTRACT(TO_CHAR(YEAR FROM TO_DATE(EMP_NO,1,2)),'RR')) "최소나이" FROM EMPLOYEE;

SELECT EMP_NAME,DEPT_CODE,
    CASE 
        WHEN DEPT_CODE IN ('D5','D6','D9')
        THEN '야근'  
        ELSE '야근없음'
    END AS 야근유무
FROM EMPLOYEE ORDER BY DEPT_CODE ASC;

SELECT EMP_NAME,DEPT_CODE,
    CASE 
        WHEN DEPT_CODE IN 'D5' THEN '총무부'  
        WHEN DEPT_CODE IN 'D6' THEN '기획부'  
        WHEN DEPT_CODE IN 'D9' THEN '영업부'  
    END AS 부서명
FROM EMPLOYEE WHERE DEPT_CODE IN ('D5','D6','D9') ORDER BY DEPT_CODE ASC ;

SELECT EMP_NAME,DEPT_CODE,TO_CHAR(TO_DATE(SUBSTR(EMP_NO,1,6),'YYMMDD'),'YY"년"MM"월"DD"일"') 생년월일,
    EXTRACT(YEAR FROM SYSDATE)-
    EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO,1,6),'RRMMDD'))+1 나이 FROM EMPLOYEE WHERE EMP_ID NOT IN (200,201,214);

SELECT SUM(DECODE(SUBSTR(HIRE_DATE,1,2),'98','1','0'))"1998년",
SUM(DECODE(SUBSTR(HIRE_DATE,1,2),'99','1','0'))"1999년",
SUM(DECODE(SUBSTR(HIRE_DATE,1,2),'00','1','0'))"2000년",
SUM(DECODE(SUBSTR(HIRE_DATE,1,2),'01','1','0'))"2001년",
SUM(DECODE(SUBSTR(HIRE_DATE,1,2),'02','1','0'))"2002년",
SUM(DECODE(SUBSTR(HIRE_DATE,1,2),'03','1','0'))"2003년",
SUM(DECODE(SUBSTR(HIRE_DATE,1,2),'04','1','0'))"2004년",
COUNT(*) FROM EMPLOYEE;
--SELECT COUNT(DECODE(EXTRACT(YEAR FROM HIRE_DATE),1999,1)) AS "1999년"
--SELECT SUM(DECODE(EXTRACT(YEAR FROM HIRE_DATE),2000,1)) AS "2000년"

----------------------------------
SELECT DEPT_CODE, SUM(SALARY) FROM EMPLOYEE GROUP BY DEPT_CODE;

SELECT DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여') AS 성별, SUM(SALARY),COUNT(*) 
FROM EMPLOYEE
WHERE DEPT_CODE IN ('D1','D2','D3') 
GROUP BY DECODE(SUBSTR(EMP_NO,8,1),'1','남','2','여')
ORDER BY 3 DESC;

SELECT DEPT_CODE, FLOOR(AVG(SALARY)) FROM EMPLOYEE GROUP BY DEPT_CODE HAVING FLOOR(AVG(SALARY))>300000;

SELECT * FROM EMPLOYEE;
--1. EMPLOYEE 테이블에서 J1직급 제외
--직급, 직급 별 사원 수, 직급별 평균급여 출력
SELECT JOB_CODE "직급",
    COUNT(*)"사원 수",
    FLOOR(AVG(SALARY)) "평균 급여"
FROM EMPLOYEE
GROUP BY JOB_CODE;
--2. EMPLOYEE 테이블에서 J1직급 제외
--입사 년도별 인원수를 조회해서 입사년 기준으로 오름차순 정렬
SELECT EXTRACT(YEAR FROM HIRE_DATE), COUNT(*)
FROM EMPLOYEE
WHERE JOB_CODE != 'J1'
GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
ORDER BY 1;

-- 부서별 성별 인원수
-- D1 남 2
-- D1 여 1
SELECT 
    DEPT_CODE, 
    DECODE(SUBSTR(EMP_NO,8,1),1,'남',2,'여') AS 성별,
    COUNT(*) 인원수
FROM EMPLOYEE
GROUP BY DEPT_CODE,DECODE(SUBSTR(EMP_NO,8,1),1,'남',2,'여')
ORDER BY 1;

--1. 오라클 전용 구문
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE = DEPT_ID;

--2. ANSI 표준구문
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

SELECT EMP_NAME, JOB_CODE FROM EMPLOYEE;
SELECT * FROM JOB;

-----1. 오라클 구문(비교하려는 컬럼 이름이 같은 경우)
SELECT EMP_NAME, EMPLOYEE.JOB_CODE, JOB_NAME 
FROM EMPLOYEE E , JOB J
WHERE EMPLOYEE.JOB_CODE = JOB.JOB_CODE;
--WHERE E.JOB_CODE = J.JOB_CODE;


--2. ANSI 표준구문(비교하려는 컬럼 이름이 같은 경우)
SELECT EMP_NAME, E.JOB.CODE, JOB_NAME
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_CODE = J.JOB_CODE);

SELECT EMP_NAME, JOB_CODE, JOB_NAME
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE);

--INNER JOIN (비교구문과 일치하는 데이터가 없으면 JOIN 결과에서 제외)
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
INNER JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

--테이블 왼쪽(EMPLOYEE)의 테이블 데이터는 다 나옴.
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

--테이블 오른쪽(EMPLOYEE)의 테이블 데이터는 다 나옴.
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
RIGHT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

--양쪽 다 겹치지 않아도? 전부 나옴
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
FULL JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID);

--CROSS JOIN
SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE
FROM EMPLOYEE
CROSS JOIN DEPARTMENT;


--EMPLOYEE E1(직원 정보용), EMPLOYEE E2(관리자 정보용)
SELECT E1.EMP_ID, E1.EMP_NAME, E1.MANAGER_ID, E2.EMP_NAME AS 매니저이름
FROM EMPLOYEE E1
LEFT JOIN EMPLOYEE E2 ON (E1.MANAGER_ID=E2.EMP_ID)
ORDER BY 1;

------------------------------------

SELECT * FROM EMPLOYEE;
SELECT * FROM DEPARTMENT;
SELECT * FROM LOCATION;

SELECT EMP_NAME, DEPT_TITLE, NATIONAL_CODE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
WHERE DEPT_CODE IN ('D9','D6');

SELECT EMP_NAME, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING (JOB_CODE);


--1번문제
SELECT EMP_NAME "사원명", EMP_NO "주민번호" ,DEPT_TITLE "부서명",JOB_NAME "직급명"
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING (JOB_CODE)
WHERE 
    SUBSTR(EMP_NO,'1','1')='7' AND
    SUBSTR(EMP_NO,'8','1')='2' AND
    SUBSTR(EMP_NAME,'1','1')='전';
 --WHERE EMP_NO LIKE '7%-2%' AND EMP_NAME LIKE '전%';
 
 
 --2번문제   
SELECT EMP_ID, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE EMP_NAME LIKE '%형%';

--3번문제
SELECT EMP_NAME "사원명", JOB_NAME "직급명", DEPT_CODE "부서코드", DEPT_TITLE "부서명"
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE DEPT_TITLE LIKE '해외영업%';

--4번문제
SELECT EMP_NAME, BONUS, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
LEFT JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
WHERE BONUS IS NOT NULL;

--5번문제
SELECT EMP_NAME "사원명", JOB_NAME "직급명", DEPT_TITLE "부서명", LOCAL_NAME "근무지역명"
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
WHERE DEPT_CODE='D2';

--6번문제
SELECT EMP_NAME "사원명", DEPT_TITLE "부서명", LOCAL_NAME "지역명", NATIONAL_NAME "국가명"
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN LOCATION ON (LOCATION_ID = LOCAL_CODE)
JOIN NATIONAL USING (NATIONAL_CODE)
WHERE NATIONAL_NAME = '한국' OR NATIONAL_NAME = '일본';
--WHERE NATIONAL_NAME IN ('한국','일본');

--7번문제
SELECT E1.EMP_NAME "사원명", DEPT_TITLE "부서명", E2.EMP_NAME "동료이름"
FROM EMPLOYEE E1 , EMPLOYEE E2
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE (E1.EMP_NAME != E2.EMP_NAME) AND E1.DEPT_CODE = E2.DEPT_CODE;

--8번문제
SELECT EMP_NAME "사원명", JOB_NAME "직급명", SALARY "급여"
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
WHERE BONUS IS NULL AND JOB_NAME IN ('차장','사원');

------------------------------------------------------------------------------------------------------------------------

--UNION :  SELECT문을 집합연산, 이후 정렬까지 진행.
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
UNION
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

--UNION ALL : 합집합이지만 정렬을 해주지 않음. 중복 제거 하지않음.
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
UNION ALL
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

--INTERSECT : 두 조회 결과의 교집합. 겹친부분만 출력
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
INTERSECT
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

--MINUS : 위 조회 결과에서 아래 조회 결과를 빼줌 = 첫번째 조회문에서 두번쨰 조회문과 겹치는부분 제거
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY > 3000000;

------------------------------------------------------------------------------------------------
--서브쿼리

--전 직원의 평균 급여보다 많은 급여를 받는 직원의 사번, 이름, 급여 조회
--1. 전직원의 평균 급여를 조회
SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE; --3047662
--2. 1에서 조회된 결과를 이용하여 쿼리문 작성
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE SALARY > (SELECT FLOOR(AVG(SALARY)) FROM EMPLOYEE);

--전지연 직원의 관리자 이름을 출력
--1. 전지연 직원의 관리자 사번(MANAGER_ID) 조회
--2. 1의 조회 결과로 관리자 이름 ㅊ출력
SELECT * FROM EMPLOYEE;
SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME='전지연';

SELECT EMP_NAME 
FROM EMPLOYEE 
WHERE EMP_ID=
(SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME='전지연');

SELECT E2.EMP_NAME
FROM EMPLOYEE E1
JOIN EMPLOYEE E2 ON (E1.MANAGER_ID = E2.EMP_ID)
WHERE E1.EMP_NAME='전지연';

--1. 윤은해와 급여가 같은 사원들의 사원번호,이름 급여를 출력
--단, 윤은해는 출력X
SELECT * FROM EMPLOYEE;
SELECT EMP_ID "사원번호", EMP_NAME "이름", SALARY "급여"
FROM EMPLOYEE
WHERE SALARY =(SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME='윤은해')AND EMP_NAME != '윤은해';


--2. EMPLOYEE 테이블에서 급여가 가장 많은 사람과, 가장 적은 사람의
--사번 이름 급여 출력
SELECT EMP_ID "사원번호", EMP_NAME "이름", SALARY "급여"
FROM EMPLOYEE
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE) 
OR SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE);
--WHERE SALARY IN ((SELECT  MAX(SALARY) FROM EMPLOYEE),(SELECT MIN(SALARY) FORM EMPLOYEE));

--3. D1,D2 부서에서 근무하는 사원들 중 급여가, D5부서 직원들의
--평균급여보다 많은 사람들의 이름 부서코드 급여 출력
SELECT EMP_NAME "이름", DEPT_CODE  "부서코드", SALARY "급여"
FROM  EMPLOYEE
WHERE DEPT_CODE IN ('D1','D2')
AND
SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE='D5');


--- 다중행 서브쿼리
-- 각 부서별 최고급여를 받는 직원의 이름, 부서코드, 급여 출력
SELECT EMP_NAME, DEPT_CODE , SALARY
FROM EMPLOYEE
WHERE SALARY IN (SELECT MAX(SALARY)
    FROM EMPLOYEE GROUP BY DEPT_CODE);

-- 비교값 > ANY() -> ()조건 값 중에서 최소 값보다 큰 값 전부 출력.
SELECT EMP_NAME, DEPT_CODE , SALARY
FROM EMPLOYEE
WHERE SALARY > ANY (SELECT MAX(SALARY)
FROM EMPLOYEE GROUP BY DEPT_CODE);

-- 비교값 < ANY() -> ()조건 값 중에서 최대값 보다 작은 값 전부 출력
SELECT EMP_NAME, DEPT_CODE , SALARY
FROM EMPLOYEE
WHERE SALARY < ANY (SELECT MAX(SALARY)
FROM EMPLOYEE GROUP BY DEPT_CODE);

-- 비교값 = ANY() -> IN과 같은 효과

-- 비교값 > ALL -> ()조건 값 중 최대값보다 크면
SELECT EMP_NAME, DEPT_CODE , SALARY
FROM EMPLOYEE
WHERE SALARY > ALL (SELECT MAX(SALARY)
FROM EMPLOYEE GROUP BY DEPT_CODE);

-- 비교값 < ALL -> ()조건 값 중 최솟값보다 작으면
SELECT EMP_NAME, DEPT_CODE , SALARY
FROM EMPLOYEE
WHERE SALARY > ALL (SELECT MAX(SALARY)
FROM EMPLOYEE GROUP BY DEPT_CODE);

-- 다중열 서브쿼리
-- 퇴사한 직원의 부서, 직급을 조회 -> ENT_YN = 'Y'
-- 퇴사한 직원과 같은부서, 같은 직급에 해당하는 사원 이름, 부서 직급코드
SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE ENT_YN='Y';

SELECT EMP_NAME, DEPT_CODE, JOB_CODE
FROM EMPLOYEE                                                                                                                                                                                                                                                                                                                                            
WHERE 
(DEPT_CODE, JOB_CODE) IN (SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE ENT_YN='Y');
--DEPT_CODE = 'D8' AND JOB_CODE = 'J6';

--상관 쿼리(상호연관 서브쿼리)
--메인쿼리 값을 서브쿼리에 주고 서브 쿼리를 수행 한 후 메인 쿼리를 수행
SELECT EMP_ID, EMP_NAME, DEPT_CODE, MANAGER_ID
FROM EMPLOYEE E1
WHERE EXISTS 
(SELECT EMP_ID FROM EMPLOYEE E2 
WHERE E1.MANAGER_ID = E2.EMP_ID);

--스칼라 서브쿼리 : 상호연관 서브쿼리이면서 결과값이 1개인 서브쿼리
-- 스칼라서브쿼리 중, (SELECT절 사용)
--모든 사원의 사번, 이름, 관리자번호, 관리자이름 조회
SELECT EMP_ID, EMP_NAME, MANAGER_ID,
(SELECT E2.EMP_NAME FROM EMPLOYEE E2 WHERE E2.EMP_ID = E1.MANAGER_ID) AS 관리자명
FROM EMPLOYEE E1;


--사원명, 부서코드, 소속부서의 평균임금을 스칼라 서브쿼리로 출력
SELECT EMP_NAME , DEPT_CODE,
FLOOR(
(SELECT AVG(SALARY) FROM EMPLOYEE E2
WHERE E2.DEPT_CODE=E1.DEPT_CODE)
)
AS 평균임금
FROM EMPLOYEE E1;

-- 인라인 뷰
-- 뷰 : 가상의 테이블
-- 인라인뷰 : FROM 절에서 사용하는 서브쿼리
-- TOP-N 분석
-- 회사에서 급여가 가장 높은 직원 5명의 이름, 부서코드, 급여 출력
SELECT ROWNUM, EMP_NAME, DEPT_CODE, SALARY 
FROM (SELECT EMP_NAME, DEPT_CODE, SALARY 
FROM EMPLOYEE ORDER BY SALARY DESC) WHERE ROWNUM <6;
--RANK() OVER : 중복 등수는 동일 등수 처리 후 등수는 그만큼 밀어서 등수 처리,
SELECT EMP_NAME, SALARY, RANK() OVER(ORDER BY SALARY DESC) FROM EMPLOYEE;
-- DENSE RANK() OVER : 중복 등수는 동일 등수처리, 후 등수 밀지 않고 등수처리
SELECT EMP_NAME, SALARY, DENSE_RANK() OVER(ORDER BY SALARY DESC) FROM EMPLOYEE;
--ROW_NUMBER() OVER : 중복 값도 오름차순에 따라 등수 처리를 나눔
SELECT EMP_NAME, SALARY, ROW_NUMBER() OVER(ORDER BY SALARY DESC) FROM EMPLOYEE;


















